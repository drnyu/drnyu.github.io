<html><head>
    <title>Dynamic Programming</title>

    <meta id="meta" name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="../lib/vamonos.css">

    <script type="text/javascript" src="../lib/vamonos-all.js"></script>

    <link rel="stylesheet" href="../deps/bootstrap.min.css">
    <link rel="stylesheet" href="../deps/bootstrap-theme.min.css">
    <script type="text/javascript" src="../deps/bootstrap.min.js"></script>
    <script type="text/javascript"
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>

    <style type="text/css">

    p.caption {
        font-size: 20px;
        font-family: monospace;
    }

    .center {
        text-align: center;
    }

    h1, h2, h3, h4, h5, h6 {
        text-align: center;
    }

    emph {
        font-style: italic;
        font-weight: bold;
    }

    a:hover {
        cursor: default;
    }

    li {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    table.matrix td.row-i.col-j {
        background-color: #ffa;
    }

    table.matrix td.row-n.col-k {
        background-color: #ada;
    }
    </style>

    <script>

    var demos = [];

    $( function(){
        tab(1);
    });

    function tab(n) {
        var inactive = [1,2,3,4,5,6,7].filter(function(x){ return x !== n })
        inactive.forEach(function(x){
            $("li#tabbutt" + x).removeClass("active");
            $("div#tab" + x).hide();
            demos[x].forEach(function(demo){
                demo.deactivate();
            });
        });
        demos[n].forEach(function(demo){ demo.activate() });
        $("li#tabbutt" + n).addClass("active");
        $("div#tab" + n).show();

        $("html, body").animate({ scrollTop: 0 }, "slow");
    }


    </script>

</head><body>
    <!-- Static navbar -->
    <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#">Dynamic Programming</a>
            </div>
            <div class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li id="tabbutt1" class="active"><a onclick="tab(1);">Introduction</a></li>
                    <li id="tabbutt2"><a onclick="tab(2);">Caching</a></li>
                    <li id="tabbutt3"><a onclick="tab(3);">Top-down vs Bottom-up</a></li>
                    <li id="tabbutt4"><a onclick="tab(4);">The Basic Idea</a></li>
                    <li id="tabbutt5"><a onclick="tab(5);">Bonus Scheduling</a></li>
                    <li id="tabbutt6"><a onclick="tab(6);">Breadcrumbs</a></li>
                    <li id="tabbutt7"><a onclick="tab(7);">Binomial Coefficients</a></li>
                </ul>
            </div><!--/.nav-collapse -->
        </div><!--/.container-fluid -->
    </div>

    <div id="tab1" class="container-fluid">

        <div class="row">
            <h3>Fibonacci's overlapping subproblems</h3>

            <div class="col-lg-4 col-lg-offset-4 col-sm-6 col-sm-offset-3">

                <p>
                    We all know and love the Fibonacci sequence, which is defined as:
                </p>

                <div class="panel panel-info">
                    <div class="panel-heading">
                        Fibonacci Formula
                    </div>
                    <div class="panel-body">
                        \begin{aligned}
                        F_0 &= F_1 = 1\\
                        F_n &= F_{n-1} + F_{n-2} \text{ for } n \geq 2
                        \end{aligned}
                    </div>
                </div>
                <p>
                    We can transform this definition into a recursive algorithm quite easily:
                </p>

                <div class="panel vamonos panel-default">
                    <div class="panel-heading">
                        Recursive Fibonacci Implementation
                    </div>
                    <div class="pseudocode-procedures">
                        <div id="fib" title="Fib(n):">
                            if n >= 1 then
                                return 1
                            else
                                return fib(n-1) + fib(n-2)
                        </div>
                    </div>
                    <div id="fib-controls"></div>
                    <table class="variable-widgets">
                        <tr><td><div id="fib-stack-var"></div></td>
                            <td><div id="fib-stack"></div></td>
                        </tr>
                    </table>
                </div>

                <script type="text/javascript">
                var fib = new Vamonos.Visualizer({
                    widgets: [
                        new Vamonos.Widget.Pseudocode("fib"),
                        new Vamonos.Widget.Controls({
                            container: "fib-controls",
                            inputVars: { n : 5 },
                        }),
                        new Vamonos.Widget.CallStack({
                            container: "fib-stack",
                            procedureNames: {
                                main: "Fib",
                            },
                        }),
                        new Vamonos.Widget.VarName({
                            container: "fib-stack-var",
                            varName: "_callstack",
                            displayName: "callstack",
                            watching: true
                        })
                    ],
                    algorithm: function(_) {
                        with (this) {
                            _(1);
                            if (n <= 1) {
                                _(2);
                                return 1;
                            }
                            _(3);
                            _(4);
                            var a = main({n:n-1});
                            var b = main({n:n-2});
                            return a + b;
                        }
                    },
                    maxFrames: 500,
                });
                </script>

                <p>
                    What could be wrong with that? For one thing, most calls to <code>fib()</code>
                    are needlessly re-computed many times with the same argument!
                </p>

                <p>
                    We say that this algorithm suffers from <emph>overlapping subproblems</emph>. As
                    an example, the value of <code>fib(3)</code> is requested -- directly or
                    indirectly -- by many other calls to <code>fib()</code>.
                </p>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(2)">Next</a></li>
        </ul>

        <script> demos[1] = [fib]; </script>
    </div>

    <div id="tab2" class="container-fluid">

        <div class="row">
            <h3>Caching</h3>
            <div class="col-sm-6 col-lg-4 col-lg-offset-2">
                <p>
                    One way to avoid computing the same value twice is to bolt on a <em>cache</em>
                    to the algorithm. At the beginning of every call to <code>fib(n)</code>, we
                    check whether the answer is already in the cache. Otherwise, we compute the
                    answer just as before, and store the answer in the cache just before
                    returning. We call this <emph>recursion with shortcuts</emph>.
                </p>

                <p>
                    This algorithm won't needlessly recompute a value <code>fib(n)</code> after
                    computing it once. But this style of coding is slightly cumbersome since:
                    <ul>
                        <li>
                            It is hard to analyze/understand, because it relies heavily on
                            side-effects. The same call to <code>fib()</code> could result in
                            different behavior based on the contents of the cache.
                        </li>

                        <li>
                            Correctly maintaining the cache is awkward when using a static/global
                            cache variable like this. For future problems we will discuss, a cache
                            can be made to work but only if it is cleared for some calls but not
                            others.
                        </li>
                    </ul>
                </p>

            </div>
            <div class="col-sm-6 col-lg-4">
                <div class="panel vamonos panel-default">
                    <div class="panel-heading">
                        Caching Fibonacci Implementation
                    </div>
                    <div class="pseudocode-procedures">
                        <div id="fib-cache" title="Fib(n):">
                            // cache[n] will store the already-computed result of Fib(n)
                            if cache[n] exists then
                                return cache[n]
                            if n <= 1 then
                                cache[n] = 1
                            else
                                cache[n] = Fib(n-1) + Fib(n-2)
                            return cache[n]
                        </div>
                    </div>
                    <div id="fib-cache-controls"></div>
                    <table class="variable-widgets">
                        <tr><td><div id="fib-cache-cache-var"></div></td>
                            <td><div id="fib-cache-cache"></div></td>
                        <tr><td><div id="fib-cache-stack-var"></div></td>
                            <td><div id="fib-cache-stack"></div></td>
                        </tr>
                    </table>
                </div>

                <script type="text/javascript">
                var fib_cache = new Vamonos.Visualizer({
                    widgets: [
                        new Vamonos.Widget.Pseudocode("fib-cache"),
                        new Vamonos.Widget.Controls({
                            container: "fib-cache-controls",
                            inputVars: { n: 5 },
                        }),
                        new Vamonos.Widget.CallStack({
                            container: "fib-cache-stack",
                            procedureNames: {
                                main: "Fib",
                            },
                        }),
                        new Vamonos.Widget.VarName({
                            container: "fib-cache-stack-var",
                            varName: "_callstack",
                            displayName: "callstack",
                            watching: true
                        }),
                        new Vamonos.Widget.VarName({
                            container: "fib-cache-cache-var",
                            varName: "cache",
                            watching: true,
                        }),
                        new Vamonos.Widget.Array({
                            container: "fib-cache-cache",
                            varName: "cache",
                            displayOnly: true,
                        }),
                        new Vamonos.Widget.UserQuiz({
                            condition: function(frame) {
                                return frame._frameNumber == 1;
                            },
                            question: function(frame) {
                                return "when calling Fib(" + frame.n +
                                       ") with an initially empty cache, what will be the first" +
                                       " entry in the cache to be added?"
                            },
                            answer: function(frame) {
                                return 1;
                            }
                        }),
                    ],
                    algorithm: function(_) {
                        with (this) {
                            if (global.cache === undefined) {
                                global.cache = [];
                            }
                            if (_(1), global.cache[n] !== undefined) {
                                _(2);
                                return global.cache[n];
                            }

                            if (_(3), n <= 1) {
                                _(4);
                                global.cache[n] = 1;
                            } else {
                                _(5);
                                _(6);
                                var a = main({n:n-1});
                                var b = main({n:n-2});
                                global.cache[n] = a + b;
                            }
                            _(7);
                            return global.cache[n];
                        }
                    },
                    maxFrames: 500,
                });
                </script>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(1)">Previous</a></li>
            <li><a onclick="tab(3)">Next</a></li>
        </ul>
        <script> demos[2] = [fib_cache]; </script>
    </div>


    <div id="tab3" class="container-fluid">
        <h3>Top-down vs Bottom-up</h3>
        <div class="row">
            <div class="col-sm-6 col-lg-4 col-lg-offset-2">
                <p>
                    In the previous example, the cache gets filled starting at the base cases 0 & 1
                    and then gets filled up in increasing order. It makes sense that you can't
                    compute <code>fib(n)</code> until <code>fib(n-1)</code> returns, filling
                    <code>cache[n-1]</code> in the process.
                </p>

                <p>
                    Let's execute the recursion-with-shortcuts algorithm, with all we can see is how
                    the cache array is filled:
                </p>

                <div class="panel vamonos panel-default">
                    <div class="panel-heading">
                        Caching Fibonacci Implementation
                    </div>
                    <div id="fib-cache2-controls"></div>
                    <table class="variable-widgets">
                        <tr><td><div id="fib-cache2-cache-var"></div></td>
                            <td><div id="fib-cache2-cache"></div></td>
                        </tr>
                    </table>
                </div>
                <script type="text/javascript">
                var fib_cache2 = new Vamonos.Visualizer({
                    widgets: [
                        new Vamonos.Widget.Controls({
                            container: "fib-cache2-controls",
                            inputVars: { n: 10 },
                        }),
                        new Vamonos.Widget.VarName({
                            container: "fib-cache2-cache-var",
                            varName: "cache",
                            watching: true,
                        }),
                        new Vamonos.Widget.Array({
                            container: "fib-cache2-cache",
                            varName: "cache",
                            displayOnly: true,
                        }),
                    ],
                    algorithm: function(_) {
                        with (this) {
                            if (global.cache === undefined) {
                                global.cache = [];
                            }
                            if (_(1), global.cache[n] !== undefined) {
                                _(2);
                                return global.cache[n];
                            }

                            if (_(3), n <= 1) {
                                _(4);
                                global.cache[n] = 1;
                            } else {
                                _(5);
                                _(6);
                                var a = main({n:n-1});
                                var b = main({n:n-2});
                                global.cache[n] = a + b;
                            }
                            _(7);
                            return global.cache[n];
                        }
                    },
                    maxFrames: 500,
                });
                </script>

                <p>
                    So the recursion-with-shortcuts approach fills the cache in a certain way, and
                    eventually returns the last item added to the cache.
                </p>

                <p>
                    If you were asked to write an algorithm that fills an array in this way, you certainly
                    wouldn't have written the recursion-with-shortcuts approach. You would have written
                    something much more direct:
                </p>
            </div>

            <div class="col-sm-6 col-lg-4">
                <div class="panel vamonos panel-default">
                    <div class="panel-heading">
                        Bottom-up Fibonacci Implementation
                    </div>
                    <div class="pseudocode-procedures">
                        <div id="fib-bot" title="Fib(n):">
                            cache[0] = cache[1] = 1
                            for i = 2 to n:
                                cache[k] = cache[k-1] + cache[k-2]
                            return cache[n]
                        </div>
                    </div>
                    <div id="fib-bot-controls"></div>
                    <table class="variable-widgets">
                        <tr><td><div id="fib-bot-cache-var"></div></td>
                            <td><div id="fib-bot-cache"></div></td>
                        </tr>
                        <tr><td><div id="fib-bot-ret-var"></div></td>
                            <td><div id="fib-bot-ret"></div></td>
                        </tr>
                    </table>
                </div>

                <script type="text/javascript">
                var fib_cache3 = new Vamonos.Visualizer({
                    widgets: [
                        new Vamonos.Widget.Pseudocode({
                            container: "fib-bot",
                            procedureName: "fib",
                        }),
                        new Vamonos.Widget.Controls({
                            container: "fib-bot-controls",
                            inputVars: { n: 10 },
                        }),
                        new Vamonos.Widget.VarName({
                            container: "fib-bot-cache-var",
                            varName: "cache",
                            watching: true,
                        }),
                        new Vamonos.Widget.Array({
                            container: "fib-bot-cache",
                            varName: "cache",
                            displayOnly: true,
                        }),
                        new Vamonos.Widget.VarName({
                            container: "fib-bot-ret-var",
                            varName: "ret",
                            displayName: "return",
                        }),
                        new Vamonos.Widget.VarDisplay({
                            container: "fib-bot-ret",
                            varName: "ret",
                        }),
                    ],
                    algorithm: {
                        main: function(_) {
                            with (this) {
                                global.ret = fib({n : n});
                            }
                        },

                        fib: function(_) {
                            with (this) {
                                _(1);
                                this.cache = global.cache = [1,1];
                                for (var i = 2; _(2), i <= n; i++) {
                                    _(3);
                                    cache[i] = cache[i-1] + cache[i-2];
                                }
                                _(4);
                                return cache[n];
                            }
                        }
                    },
                    maxFrames: 500,
                });
                </script>

                <p>
                    Isn't that nicer?
                </p>

                <p>
                    The two recursion-based approaches work <emph>top-down</emph>, considering
                    larger problems in terms of smaller subproblems. This last, direct approch is
                    <emph>bottom-up</emph>, solving larger and larger subproblems until the desired
                    subproblem has been solved.
                </p>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(2)">Previous</a></li>
            <li><a onclick="tab(4)">Next</a></li>
        </ul>
        <script>demos[3] = [fib_cache2, fib_cache3];</script>
    </div>

    <div id="tab4" class="container-fluid">
        <div class="row">
            <div class="col-lg-4 col-lg-offset-4 col-sm-6 col-sm-offset-3">

                <h3>The Basic Idea</h3>

                <p>
                    We've seen 3 ways of doing the same simple thing: simple recursion, recursion
                    with shortcuts, and bottom-up.
                </p>

                <p>
                    The bottom-up approach is all there is to dynamic programming! Solve the base
                    cases, then solve the next-smallest subproblems, and so on until you have solved
                    the desired problem.
                </p>

                <p>
                    Many/most students do indeed start out by thinking about the Fibonacci sequence
                    in terms of the bottom-up approach (computing the nth Fibonacci number by
                    enumerating 0,1,2,3,5,8,...). Then a CS education takes great pains to force
                    students to think about things in a recursive way ($F(n) = F(n-1) + F(n-2)$).
                </p>

                <p>
                    Now we are asking you to go back to the bottom-up approach? Don't worry, the
                    Fibonacci example is misleadingly simple. To use dynamic programming to its
                    greatest benefit, you <emph>must</emph> understand the recursive top-down
                    approach first, only then can you convert to a bottom-up algorithm.
                </p>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(3)">Previous</a></li>
            <li><a onclick="tab(5)">Next</a></li>
        </ul>
        <script>demos[4] = [];</script>
    </div>

    <div id="tab5" class="container-fluid">
        <h3>First example: Work Bonus Scheduling</h3>

        <div class="row">
            <div class="col-sm-6 col-lg-4 col-lg-offset-2">
                <p>
                    You work in outdoor construction in a hot climate, and get paid a daily bonus
                    based on the high temperature that day. If the high temperature is T degrees,
                    then you get a $T bonus (temperatures in this region are always positive). Local
                    safety regulations also say that no one can work on consecutive days.
                </p>

                <p>
                    Suppose you know the forecast for the next n days, represented as an array
                    <code>T[1..n]</code>. <code>T[i]</code> is the high temperature, i days from
                    now. What is the maximum bonus you can receive over the next n days, assuming
                    the forecast is correct and assuming you are in it just for the money (and are
                    willing to work in any weather)?
                </p>

                <p>
                    Example: Suppose the forecast is <code>[93,91,87,72,85,88]</code>. You can work
                    on odd days to get a bonus of 93+87+85=265, or even days to get a bonus of
                    91+72+88=251. But even better would be to work on days 1, 3, and 6 to get a
                    bonus of 93+87+88=268.
                </p>

                <p>
                    To get started solving this problem, let's first just worry about computing
                    <em>the maximum bonus</em>, and not worry about <em>which schedule achieves</em>
                    the maximum bonus. So, given the above example forecast, we would like to
                    compute the number 268.
                </p>

                <p>
                    Now suppose you are given a forecast <code>T[1..n]</code>. What do you do? To
                    master the dynamic programming technique, you'll have to get used to the
                    following kind of logic:

                    <ol>
                        <li>
                            If you decide to work on the nth day, you will get a bonus of
                            <code>T[n]</code>. But then you can't work on the (n-1)th day, so the
                            remainder of your schedule will be some subset of days 1 through n-2.
                        </li>

                        <li>
                            If you decide <em>not</em> to work on the nth day, then you'll be
                            working in some subset of days 1 through n-1.
                        </li>
                    </ol>

                    Those are the only two choices, right? Either work on the nth day, or don't work
                    on the nth day.
                </p>
            </div>
            <div class="col-sm-6 col-lg-4">

                <p>
                    Define best[k] to be the maximum possible bonus you can get by working during
                    days 1 through k. Then let's revisit those two cases:

                    <ol>
                        <li>
                            You work on the nth day, earning <code>T[n]</code>. You also work some
                            time during days 1 through n-2. The most that can give you is
                            <code>best[n-2]</code>. Hence the most you can get from this case is
                            <code>best[n-2] + T[n]</code>.
                        </li>

                        <li>
                            You don't work on the nth day, you only work during days 1 through
                            n-1. The most you that can give you is <code>best[n-1]</code>.
                        </li>
                    </ol>

                    So when thinking about what to do on the nth day, there are only two choices:
                    choose to earn <code>T[n] + best[n-2]</code>, or choose to earn
                    <code>best[n-1]</code>. Of course you would choose whichever of these is
                    highest, right? So we get:
                </p>


                <div class="panel panel-info">
                    <div class="panel-heading">
                        Work Bonus Formula
                    </div>
                    <div class="panel-body">
                        $$best[n] = max\{ T[n] + best[n-2], best[n-1] \}$$
                    </div>
                </div>

                <p>
                    Of course, this formula only makes sense when n > 1. The base cases have to be
                    <code>best[1] = T[1]</code> (it's always better to work than not to work, when
                    considering only one day) and <code>best[0] = 0</code> (working on zero days
                    gives you zero bonus).
                </p>

                <p>
                    Hey, this is a recursive formula, which we could translate directly to a
                    recursive algorithm. But it would suffer from overlapping subproblems! Calling
                    it with input n would result in recursive calls on n-1 and n-2, just like the
                    recursive algorithm for the Fibonacci numbers!
                </p>

                <p>
                    So instead, we will use dynamic programming, computing <code>best[k]</code>
                    values <emph>bottom-up</emph>. Remember the basic approach? We are just filling
                    in a table. The first entries we fill in are the base cases. Then we fill
                    entries in a legal order, using the recurrence formula.
                </p>
            </div>
        </div>


        <div class="jumbotron row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="row panel vamonos panel-default">
                <div class="panel-heading">
                    Scheduling Implementation
                </div>
                <div class="col-sm-6 nopadding">
                    <div id="schedule-controls"></div>
                    <div class="pseudocode-procedures">
                        <div id="schedule" title="Schedule(T[1..n])">
                            best[0] = 0
                            best[1] = T[1]
                            for k = 2 to n:
                                a = best[k-2] + T[k]
                                b = best[k-1]
                                best[k] = max{ a, b }
                            return best[n]
                        </div>
                    </div>
                </div>
                <div class="col-sm-6 nopadding">
                    <table class="variable-widgets">
                        <tr><td><div id="schedule-t-var"></div></td>
                            <td><div id="schedule-t"></div></td>
                        </tr>
                        <tr><td><div id="schedule-best-var"></div></td>
                            <td><div id="schedule-best"></div></td>
                        </tr>
                        <tr><td><div id="schedule-ret-var"></div></td>
                            <td><div id="schedule-ret"></div></td>
                        </tr>
                    </table>
                </div>
            </div>
            </div>
        </div>

        <script type="text/javascript">
        var schedule = new Vamonos.Visualizer({
            widgets: [
                new Vamonos.Widget.Pseudocode({
                    container: "schedule",
                    procedureName: "sched",
                }),
                new Vamonos.Widget.Controls({
                    container: "schedule-controls",
                }),
                new Vamonos.Widget.VarName({
                    container: "schedule-t-var",
                    varName: "T",
                    watching: true,
                }),
                new Vamonos.Widget.Array({
                    container: "schedule-t",
                    varName: "T",
                    defaultInput: [0, 3,1,4,1,5,9,2,6,5],
                    ignoreIndexZero: true,
                    cssRules: [[">", "k", "shaded"]],
                    showIndices: ["k"],
                    firstCellBlank: true,
                }),
                new Vamonos.Widget.VarName({
                    container: "schedule-best-var",
                    varName: "best",
                    watching: true,
                }),
                new Vamonos.Widget.Array({
                    container: "schedule-best",
                    varName: "best",
                    displayOnly: true,
                }),
                new Vamonos.Widget.VarName({
                    container: "schedule-ret-var",
                    varName: "ret",
                    displayName: "return",
                }),
                new Vamonos.Widget.VarDisplay({
                    container: "schedule-ret",
                    varName: "ret",
                }),
                new Vamonos.Widget.UserQuiz({
                    condition: function(frame, frames) {
                        var bestLength = 2;
                        var n = frame._frameNumber - 1;
                        console.log(frames[n+1]);
                        return frame.best !== undefined &&
                               frame.best.length == bestLength &&
                               frames[n+1].best !== undefined &&
                               frames[n+1].best.length == bestLength + 1;
                    },
                    question: "What will the next value of best be?",
                    answer: function(frame, frames) {
                        var n = frame._frameNumber - 1;
                        var b = frames[n+1].best;
                        return b[b.length - 1];
                    }
                }),
            ],
            algorithm: {
                main: function(_) {
                    with (this) {
                        global.ret = sched({ T: T });
                    }
                },

                sched: function(_) {
                    with (this) {
                        _(1);
                        this.best = global.best = [0];
                        _(2);
                        best[1] = T[1];
                        for (k = 2; _(3), k < T.length; k++) {
                            _(4);
                            var a = best[k-2] + T[k];
                            _(5);
                            var b = best[k-1];
                            _(6);
                            best[k] = Math.max(a, b);
                        }
                        _(7);
                        return best[T.length - 1];
                    }
                }
            },
            maxFrames: 500,
        });
        </script>

        <ul class="pager">
            <li><a onclick="tab(4)">Previous</a></li>
            <li><a onclick="tab(6)">Next</a></li>
        </ul>
        <script>demos[5] = [schedule];</script>
    </div>

    <div id="tab6" class="container-fluid">
        <h1>Getting the answer, not just the number</h1>
        <div class="row">
            <div class="col-lg-4 col-lg-offset-2 col-sm-6">
                <p>
                    For our previous problem, we can now find the best bonus amount for a given
                    forecast. But we probably also care about what schedule actually achieves that bonus
                    amount. Let's discuss how to do that.
                </p>

                <p>
                    The idea is that each time we compute <code>best[k]</code> (a number), we should
                    also write down and remember <em>how</em> to achieve <code>best[k]</code>. In
                    this case, we need to write down the schedule that achieves
                    <code>best[k]</code>. There are several ways to do this, but perhaps the
                    simplest is as a string of <code>"Y"</code> and <code>"N"</code> characters. So
                    the string <code>"YNNYN"</code> represents the schedule of working on days 1 &
                    4, and resting on days 2, 3 & 5.
                </p>

                <p>
                    Let's store the schedules in an array <code>soln[1..n]</code>. Again, the rule
                    is: every time you save a number to <code>best[k]</code>, you must also save the
                    corresponding schedule to <code>soln[k]</code>. Note that <code>soln[k]</code>
                    must be a string of length k.
                </p>

                <p>
                    The base cases are: <code>best[1] = T[1]</code>, and <code>best[0] =
                    0</code>. What are the corresponding values to put in <code>soln[]</code>? The
                    schedule that achieves 0 is the empty string, and the schedule that achieves
                    <code>T[1]</code> is <code>"Y"</code>. Note that the lengths of strings
                    <code>soln[0]</code> and <code>soln[1]</code> match what we expect.
                </p>

                <p>
                    Now, for <code>best[k]</code> there are two possibilities:

                    <ol>
                        <li>
                            <code>best[k] = best[k-2] + T[k]</code>. This happens when we work on
                            the kth day and rest on the (k-1)th day. So the last 2 characters of
                            <code>soln[k]</code> should be <code>"NY"</code>. But what should
                            <code>soln[k]</code> say for the other days? We know that the other days
                            contribute <code>best[k-2]</code> amount to the total. Conveniently,
                            <code>soln[k-2]</code> is a schedule for those days that achieves it. Hence, we
                            have <code>soln[k] = soln[k-2] + "NY"</code>, where the <code>+</code> here
                            means concatenation.
                        </li>
                        <li>
                            <code>best[k] = best[k-1]</code>. This happens when we rest on the kth
                            day. So the last character of <code>soln[k]</code> must be
                            <code>"N"</code>. What is the rest of the schedule? Well, it's a
                            schedule for days 1 through k-1 that achieves bonus
                            <code>best[k-1]</code>. We have already written down such a schedule,
                            it's simply <code>soln[k-1]</code>. So we have <code>soln[k] = soln[k-1]
                            + "N"</code> in this case.
                        </li>
                    </ol>
                </p>

            </div>
            <div class="col-lg-4 col-sm-6">
                <p>
                    Putting it all together, we have to break up the "max" expression into an if-statement:
                </p>
                <div class="panel vamonos panel-default">
                    <div class="panel-heading">
                        Scheduling-Breadcrumbs Implementation
                    </div>
                    <div id="crumbs-controls"></div>
                    <div class="pseudocode-procedures">
                        <div id="crumbs" title="Schedule(T[1..n])">
                            best[0] = 0
                            soln[0] = ""
                            best[1] = T[1]
                            soln[1] = "Y"
                            for k = 2 to n:
                                if best[k-2] + T[k] > best[k-1]
                                    best[k] = best[k-2] + T[k]
                                    soln[k] = soln[k-2] + "NY"
                                else
                                    best[k] = best[k-1]
                                    soln[k] = soln[k-1] + "N"
                            return soln[n] + " achieves bonus " + best[n]
                        </div>
                    </div>
                    <table class="variable-widgets">
                        <tr><td><div id="crumbs-t-var"></div></td>
                            <td><div id="crumbs-t"></div></td>
                        </tr>
                        <tr><td><div id="crumbs-best-var"></div></td>
                            <td><div id="crumbs-best"></div></td>
                        </tr>
                        <tr><td><div id="crumbs-soln-var"></div></td>
                            <td><div id="crumbs-soln"></div></td>
                        </tr>
                        <tr><td><div id="crumbs-ret-var"></div></td>
                            <td><div id="crumbs-ret"></div></td>
                        </tr>
                    </table>
                </div>

                <script type="text/javascript">
                var crumbs = new Vamonos.Visualizer({
                    widgets: [
                        new Vamonos.Widget.Pseudocode({
                            container: "crumbs",
                            procedureName: "crumbs",
                        }),
                        new Vamonos.Widget.Controls({
                            container: "crumbs-controls",
                        }),
                        new Vamonos.Widget.VarName({
                            container: "crumbs-stack-var",
                            varName: "_callstack",
                            displayName: "calls",
                            watching: true
                        }),
                        new Vamonos.Widget.VarName({
                            container: "crumbs-t-var",
                            varName: "T",
                        }),
                        new Vamonos.Widget.Array({
                            container: "crumbs-t",
                            varName: "T",
                            defaultInput: [0, 3,1,4,1,5,9,2,6,5],
                            ignoreIndexZero: true,
                            cssRules: [[">", "k", "shaded"]],
                            showIndices: ["k"],
                            firstCellBlank: true,
                        }),
                        new Vamonos.Widget.VarName({
                            container: "crumbs-best-var",
                            varName: "best",
                            watching: true,
                        }),
                        new Vamonos.Widget.Array({
                            container: "crumbs-best",
                            varName: "best",
                            displayOnly: true,
                        }),
                        new Vamonos.Widget.VarName({
                            container: "crumbs-soln-var",
                            varName: "soln",
                        }),
                        new Vamonos.Widget.Array({
                            container: "crumbs-soln",
                            varName: "soln",
                            displayOnly: true,
                        }),
                        new Vamonos.Widget.VarName({
                            container: "crumbs-ret-var",
                            varName: "ret",
                            displayName: "return",
                        }),
                        new Vamonos.Widget.VarDisplay({
                            container: "crumbs-ret",
                            varName: "ret",
                        }),
                    ],
                    algorithm: {
                        main: function(_) {
                            with (this) {
                                global.ret = crumbs({ T:T });
                            }
                        },
                        crumbs: function(_) {
                            with (this) {
                                _(1);
                                this.best = global.best = [0];
                                _(2);
                                this.soln = global.soln = [""];
                                _(3);
                                best[1] = T[1];
                                _(4);
                                soln[1] = "Y";
                                for (k = 2; _(5), k < T.length; k++) {
                                    if (_(6), best[k-2] + T[k] > best[k-1]) {
                                        _(7);
                                        best[k] = best[k-2] + T[k];
                                        _(8);
                                        soln[k] = soln[k-2] + "NY";
                                    } else {
                                        _(9);
                                        _(10);
                                        best[k] = best[k-1];
                                        _(11);
                                        soln[k] = soln[k-1] + "N";
                                    }
                                }
                                _(12);
                                notifyQuiz(T, soln);
                                return soln[T.length - 1] + " achieves bonus " + best[T.length - 1];
                            }
                        },
                    },
                    maxFrames: 500,
                });

                function maxIndices(T){
                    var t = -Infinity;
                    var indices = [];
                    T.forEach(function(x,i){
                        if (x > t) {
                            t = x;
                            indices = [i];
                        } else if (x == t) {
                            indices.push(i);
                        }
                    });
                    return indices;
                }

                function notifyQuiz(T, soln){
                    var indices = maxIndices(T);
                    var result = true;
                    indices.forEach(function(i){
                        if (soln[soln.length-1][i-1] === "Y") {
                            result = false;
                        }
                    });
                    setQuizText(result);
                }

                function setQuizText(complete){
                    var $q = $("#crumbs-quiz");
                    var $a = $("#crumbs-quiz-answer");
                    if (complete) {
                        $a.text("Good job!");
                        $a.addClass("bg-success");
                        $a.removeClass("bg-warning");
                        $q.removeClass("panel-warning");
                        $q.removeClass("panel-danger");
                        $q.addClass("panel-success");
                    } else {
                        $a.text("The current input uses the hottest day. Try again!");
                        $a.addClass("bg-warning");
                        $a.removeClass("bg-success");
                        $q.removeClass("panel-success");
                        $q.removeClass("panel-warning");
                        $q.addClass("panel-danger");
                    }
                }

                </script>
                <p>
                    I happen to think that there is some elegance in how the two arrays, "best" and
                    "soln", are always accessed in a similar manner.
                </p>
            </div>
        </div>

        <div class="row">
            <div class="col-sm-6 col-sm-offset-3">
                <div id="crumbs-quiz" class="panel panel-warning">
                    <div class="panel-heading">Breadcrumbs Quiz</div>
                    <div class="panel-body">
                        Can you come up with an input whose optimal solution involves <em>not</em> working on
                        the day with the highest temperature?
                        <span id="crumbs-quiz-answer"></span>
                    </div>
                </div>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(5)">Previous</a></li>
            <li><a onclick="tab(7)">Next</a></li>
        </ul>
        <script>demos[6] = [crumbs];</script>
    </div>

    <div id="tab7" class="container-fluid">

        <h1>Another example: Binomial coefficients</h1>

        <div class="row">
            <div class="col-lg-4 col-lg-offset-2 col-sm-6">

                <p>
                    You may have seen the formula for binomial coefficients ${n \choose k} =
                    \frac{n!}{k!(n-k)!}$, but this is a bad way to actually <em>compute</em> these
                    numbers. For instance, even if the final result is small (ex: ${1000 \choose 1} =
                    1000$) the intermediate values of this computation may be huge (ex:
                    $1000!$).
                </p>

                <p>
                    Another way to compute binomial coefficients is to use Pascal's identity, which
                    is recursive:
                </p>

                <div class="panel panel-info">
                    <div class="panel-heading">
                        Pascal's Identity
                    </div>
                    <div class="panel-body">
                        \begin{aligned}
                        {n \choose 0} &= {n \choose n} = 1\\
                        {n \choose k} &= {n-1 \choose k-1} + {n-1 \choose k}
                        \end{aligned}
                    </div>
                </div>

                <p>
                    We could blindly convert this recursive formula into a recursive algorithm:
                </p>


                <div class="panel vamonos panel-default">
                    <div class="panel-heading">
                        Recursive Implementation
                    </div>
                    <div class="pseudocode-procedures">
                        <div id="choose1" title="Choose(n,k):">
                            if k == 0 or k == n:
                                return 1
                            else
                                return Choose(n-1,k-1) + Choose(n-1,k)
                        </div>
                    </div>
                    <div id="choose1-controls"></div>
                    <table class="variable-widgets">
                        <tr><td><div id="choose1-stack-var"></div></td>
                            <td><div id="choose1-stack"></div></td>
                        </tr>
                    </table>
                </div>

                <script type="text/javascript">
                var choose1 = new Vamonos.Visualizer({
                    widgets: [
                        new Vamonos.Widget.Pseudocode({
                            container: "choose1",
                            procedureName: "Choose",
                        }),
                        new Vamonos.Widget.Controls({
                            container: "choose1-controls",
                            inputVars: {
                                n: 10,
                                k: 5,
                            },
                        }),
                        new Vamonos.Widget.CallStack({
                            container: "choose1-stack",
                            procedureNames: {
                                main: "Choose",
                            },
                        }),
                        new Vamonos.Widget.VarName({
                            container: "choose1-stack-var",
                            varName: "_callstack",
                            displayName: "callstack",
                            watching: true
                        })
                    ],
                    algorithm: {
                        main: function(_) {
                            with (this) {
                                if (_(1), k == 0 || k == n) {
                                    _(2);
                                    return 1;
                                } else {
                                    _(3);
                                    _(4);
                                    return main({ n:n-1, k:k-1 }) + main({ n:n-1, k:k });
                                }
                            }
                        },
                    },
                    maxFrames: 2000,
                });
                </script>
                <p>
                    But again this algorithm suffers from serious overlapping subproblems!
                </p>

            </div>

            <div class="col-lg-4 col-sm-6">

                <p>
                    The dynamic programming approach would be to fill up a table/cache with all of
                    the desired values. In this case, the table will be two-dimensional, so
                    <code>cache[n][k]</code> will remember the output of ${n \choose k}$.
                </p>

                <p>
                    First, we fill in the base cases: in this case, there are many. Then we have to
                    fill in everything else. We know we will have to fill entry $(i,j)$ of the table
                    using the expression:
                </p>

                <div class="panel panel-info">
                    <div class="panel-heading">
                        Cache Definition
                    </div>
                    <div class="panel-body math">
                        $$cache[i,j] = cache[i-1,j-1] + cache[i-1,j]$$
                    </div>
                </div>

                <p>
                    We just have to loop over value of $(i,j)$ in a way that makes this legal. That
                    is, we want <code>cache[i-1,j-1]</code> and <code>cache[i-1,j]</code> to already
                    exist when it comes time to fill in <code>cache[i,j]</code>.
                </p>

                <p>
                    There are several legal ways to fill up the cache, and here's one:
                </p>


                <div class="panel vamonos panel-default">
                    <div class="panel-heading">
                        Caching Implementation
                    </div>
                    <div class="pseudocode-procedures">
                        <div id="cache2" title="Choose(n,k):">
                            for i = 0 to n:
                                cache[i,0] = 1
                                cache[i,i] = 1
                            for i = 1 to n:
                                for j = 1 to i:
                                    cache[i,j] = cache[i-1,j-1] + cache[i-1,j]
                            return cache[n,k]
                        </div>
                    </div>
                    <div id="cache2-controls"></div>
                    <table class="variable-widgets">
                        <tr><td><div id="cache2-cache-var"></div></td>
                            <td><div id="cache2-cache"></div></td>
                        <tr><td><div id="cache2-ret-var"></div></td>
                            <td><div id="cache2-ret"></div></td>
                        </tr>
                    </table>
                </div>

                <script type="text/javascript">
                var choose2 = new Vamonos.Visualizer({
                    widgets: [
                        new Vamonos.Widget.Pseudocode({
                            container: "cache2",
                            procedureName: "bin",
                        }),
                        new Vamonos.Widget.Controls({
                            container: "cache2-controls",
                            inputVars: {
                                n: 10,
                                k: 5,
                            },
                        }),
                        new Vamonos.Widget.VarName({
                            container: "cache2-ret-var",
                            varName: "ret",
                            displayName: "return",
                        }),
                        new Vamonos.Widget.VarDisplay({
                            container: "cache2-ret",
                            varName: "ret",
                        }),
                        new Vamonos.Widget.VarName({
                            container: "cache2-cache-var",
                            varName: "cache",
                            watching: true,
                        }),
                        new Vamonos.Widget.Matrix({
                            container: "cache2-cache",
                            varName: "cache",
                            cssRules: [
                                ["col", ">", "row", "shaded"],
                                ["row", "=", "i", "row-i"],
                                ["col", "=", "j", "col-j"],
                                ["row", "=", "n", "row-n"],
                                ["col", "=", "k", "col-k"],
                            ],
                            showIndices: [
                                ["row","i"],
                                ["col","j"],
                                ["row","n"],
                                ["col","k"],
                            ],
                        }),
                    ],
                    algorithm: {
                        main: function(_) {
                            with (this) {
                                global.ret = bin({ n:n, k:k });
                            }
                        },
                        bin: function(_) {
                            with (this) {
                                global.cache = this.cache = [];
                                _(1);
                                for (global.i = 0; _(1), global.i <= n; global.i++) {
                                    _(2);
                                    cache[global.i] = [1];
                                    _(3);
                                    cache[global.i][global.i] = 1;
                                }
                                for (global.i = 1; global.i <= n; _(4), global.i++) {
                                    for (global.j = 1; global.j < global.i; _(5), global.j++) {
                                        _(6);
                                        cache[global.i][global.j] =
                                            cache[global.i-1][global.j-1] +
                                            cache[global.i-1][global.j];
                                    }
                                    global.j = undefined;
                                }
                                global.i = undefined;
                                _(7);
                                return cache[n][k];
                            }
                        },
                    },
                    maxFrames: 500,
                });
                </script>
                <p>
                    Do you see the resemblance to Pascal's triangle?
                </p>
            </div>
        </div>

        <div class="row">
            <div class="col-lg-4 col-lg-offset-4 col-sm-6 col-sm-offset-3">
                <div id="crumbs-quiz" class="panel panel-default panel-warning">
                    <div class="panel-heading">Cache Quiz</div>
                    <div class="panel-body">
                        Can you think of different legal ways to fill up the cache? How would it change the code?
                    </div>
                </div>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(6)">Previous</a></li>
        </ul>
        <script>demos[7] = [choose1, choose2];</script>
    </div>

</body>

</html>
